<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>
			常见的七种排序算法解析 
		</title>
		<link rel="stylesheet" type="text/css" href="../css/wxstyle.css" />
		<style type="text/css">
			@import url("../css/wxstyle.css");
		</style>
<div id="js_article" class="rich_media">
    
    <div class="rich_media_inner">
                
      
        
        <div id="page-content" class="rich_media_area_primary">
            
                        <div id="img-content">

                <h2 class="rich_media_title" id="activity-name">
                    常见的七种排序算法解析                                    </h2>
              <p style="text-align: justify;"><span style="color: rgb(171, 25, 66);"><strong><span style="font-size: 14px;"></span></strong></span></p><section style="text-align: left;overflow: hidden;"><section class="" style="font-size: 1.125em;vertical-align: middle;line-height: 1.8em;text-align: center;padding-right: 0.5em;padding-bottom: 500px;padding-left: 0.5em;color: rgb(255, 255, 255);width: 16%;min-width: 1em;box-sizing: border-box;margin-bottom: -500px;display: inline-block;background-color: rgb(197, 63, 70);"><p class="">01</p></section><section style="vertical-align: top;padding-bottom: 500px;margin-bottom: -500px;width: 84%;box-sizing: border-box;background-color: #dedede;display: inline-block;"><section style="width: 6%;min-width: 1em;vertical-align: middle;display: inline-block;"><section class="" style="border-width: 0.5em 0px 0.5em 0.5em;border-style: solid;border-color: transparent transparent transparent rgb(197, 63, 70);vertical-align: middle;display: inline-block;"></section></section><section style="line-height: 1.5;font-size: 1.125em;padding-right: 0.8em;padding-left: 0.5em;vertical-align: middle;box-sizing: border-box;width: 94%;display: inline-block;"><p style="padding-top: 4px;">选择排序</p></section></section></section></section><p><br></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">实现原理</span></strong></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">首先从未排序序列中找到最小的元素，放置到排序序列的起始位置，然后从剩余的未排序序列中继续寻找最小元素，放置到已排序序列的末尾。所以称之为选择排序。</span></p><p><br></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">代码实现</span></strong></p><p><br></p><p><img data-s="300,640" data-type="png" data-src="http://mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjWZib4jQghCMfCbzw8wicCckAvc7XvrNicEHsjSFkCU7aabKibXfMicP2nOzD1VsnWL6UJmaLhtJzQey5A/0?wx_fmt=png" style="width: auto !important; height: auto !important; visibility: visible !important;" class="" data-ratio="0.7114337568058077" data-w="551" src="./常见的七种排序算法解析_files/640(1)" data-fail="0"></p><p style="text-align: justify;"><br></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">案例分析</span></strong></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjWZib4jQghCMfCbzw8wicCckApFaj2ibHTNygJ5jn9nP7RvdJ0CjXRiaKJ5rfHIKzpRWKTYNcPxHkD8sw/0?wx_fmt=jpeg" class="" data-ratio="1.3333333333333333" data-w="1080" data-type="jpeg" style="width: 419px !important; height: auto !important; visibility: visible !important;" _width="419px" src="./常见的七种排序算法解析_files/640(2)" data-fail="0"></span></p><p><br></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">时间复杂度与空间复杂度</span></strong></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">每次要找一遍最小值，最坏情况下找n次，这样的过程要执行n次，所以时间复杂度还是O(n^2)。空间复杂度是O(1)。</span></p><p><br></p><p style="text-align: justify;"><span style="color: rgb(171, 25, 66);"><strong><span style="font-size: 14px;"></span></strong></span></p><section label="Copyright © 2015 playhudong All Rights Reserved." style="border: none;margin: 1em auto;text-align: center;" donone="shifuMouseDownStyle(&#39;shifu_bus_003&#39;)"><section style="text-align: left;overflow: hidden;"><section class="" style="font-size: 1.125em;vertical-align: middle;line-height: 1.8em;text-align: center;padding-right: 0.5em;padding-bottom: 500px;padding-left: 0.5em;color: rgb(255, 255, 255);width: 16%;min-width: 1em;box-sizing: border-box;margin-bottom: -500px;display: inline-block;background-color: rgb(197, 63, 70);"><p class="">02</p></section><section style="vertical-align: top;padding-bottom: 500px;margin-bottom: -500px;width: 84%;box-sizing: border-box;background-color: #dedede;display: inline-block;"><section style="width: 6%;min-width: 1em;vertical-align: middle;display: inline-block;"><section class="" style="border-width: 0.5em 0px 0.5em 0.5em;border-style: solid;border-color: transparent transparent transparent rgb(197, 63, 70);vertical-align: middle;display: inline-block;"></section></section><section style="line-height: 1.5;font-size: 1.125em;padding-right: 0.8em;padding-left: 0.5em;vertical-align: middle;box-sizing: border-box;width: 94%;display: inline-block;"><p style="padding-top: 4px;">快速排序</p></section></section></section></section><p class=""><br></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">实现原理</span></strong></p><p><br></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p style="text-align: justify;"><span style="font-size: 14px;">在数据集之中，选择一个元素作为”基准”（pivot）。</span></p></li><li><p style="text-align: justify;"><span style="font-size: 14px;">所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。这个操作称为分区 (partition)。</span></p></li><li><p style="text-align: justify;"><span style="font-size: 14px;">操作，分区操作结束后，基准元素所处的位置就是最终排序后它的位置。</span></p></li><li><p style="text-align: justify;"><span style="font-size: 14px;">对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。</span></p></li></ul><p><br></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">代码实现</span></strong></p><p><br></p><p><img data-s="300,640" data-type="png" data-src="http://mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjWZib4jQghCMfCbzw8wicCckAKdOG1ZZvYVWOWibCBERBkfe7SfAFRprN7HiaW9yfu4N22RoZKKnnYtsw/0?wx_fmt=png" style="width: auto !important; height: auto !important; visibility: visible !important;" class="" data-ratio="0.7527624309392266" data-w="724" src="./常见的七种排序算法解析_files/640(3)" data-fail="0"></p><p style="text-align: justify;"><br></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">案例分析</span></strong></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjWZib4jQghCMfCbzw8wicCckAJ5yc4OP2RpXErhyUXic0xPwXr0TaMQ2NJiaRX86DiafdXybia1X6C8z0nQ/0?wx_fmt=jpeg" class="" data-ratio="1.3333333333333333" data-w="1080" data-type="jpeg" style="width: 422px !important; height: auto !important; visibility: visible !important;" _width="422px" src="./常见的七种排序算法解析_files/640(4)" data-fail="0"></span></p><p><br></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">时间复杂度与空间复杂度</span></strong></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">快速排序也是一个不稳定排序，平均时间复杂度是O(nlogn)。空间复杂度是O(logn)。</span></p><p><br></p><p style="text-align: justify;"><span style="color: rgb(171, 25, 66);"><strong><span style="color: rgb(171, 25, 66);font-size: 14px;"></span></strong></span></p><section label="Copyright © 2015 playhudong All Rights Reserved." style="border: none;margin: 1em auto;text-align: center;" donone="shifuMouseDownStyle(&#39;shifu_bus_003&#39;)"><section style="text-align: left;overflow: hidden;"><section class="" style="font-size: 1.125em;vertical-align: middle;line-height: 1.8em;text-align: center;padding-right: 0.5em;padding-bottom: 500px;padding-left: 0.5em;color: rgb(255, 255, 255);width: 16%;min-width: 1em;box-sizing: border-box;margin-bottom: -500px;display: inline-block;background-color: rgb(197, 63, 70);"><p class="">03</p></section><section style="vertical-align: top;padding-bottom: 500px;margin-bottom: -500px;width: 84%;box-sizing: border-box;background-color: #dedede;display: inline-block;"><section style="width: 6%;min-width: 1em;vertical-align: middle;display: inline-block;"><section class="" style="border-width: 0.5em 0px 0.5em 0.5em;border-style: solid;border-color: transparent transparent transparent rgb(197, 63, 70);vertical-align: middle;display: inline-block;"></section></section><section style="line-height: 1.5;font-size: 1.125em;padding-right: 0.8em;padding-left: 0.5em;vertical-align: middle;box-sizing: border-box;width: 94%;display: inline-block;"><p style="padding-top: 4px;">冒泡排序</p></section></section></section></section><p class=""><br></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">实现原理</span></strong></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">依次比较相邻的两个元素，如果第一个元素大于第二个元素就交换它们的位置。这样比较一轮之后，最大的元素就会跑到队尾。然后对未排序的序列重复这个过程，最终转换成有序序列。</span></p><p><br></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">代码实现</span></strong></p><p><br></p><p><img data-s="300,640" data-type="png" data-src="http://mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjWZib4jQghCMfCbzw8wicCckAy2ictGJxkfxSMXKnEpcZia1SwiconMrxlickKU4NzXNEVfWMOzosGBEu6A/0?wx_fmt=png" style="width: auto !important; height: auto !important; visibility: visible !important;" class="" data-ratio="0.4414715719063545" data-w="598" src="./常见的七种排序算法解析_files/640(5)" data-fail="0"></p><p style="text-align: justify;"><br></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">案例分析</span></strong></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">以数组 arr = [3 4 2 8 0] 为例说明，加粗的数字表示每次循环要比较的两个数字：</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">第一次外循环</span></p><p><br></p><blockquote><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">( 3 4 2 8 0 ) → ( 3 4 2 8 0 )， 4 &gt; 3 位置不变 ( 3 4 2 8 0 ) → (3 2 4 8 0 )， 4 &gt; 2 交换位置 ( 3 2 4 8 0 ) → ( 3 2 4 8 0 )， 8 &gt; 4 位置不变 ( 3 2 4 8 0 ) → ( 3 2 4 0 8 )， 8 &gt; 0 交换位置</span></p></blockquote><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">第二次外循环（除开最后一个元素8，对剩余的序列）</span></p><p><br></p><blockquote><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">( 3 2 4 0 8 ) → ( 2 3 4 0 8 )， 3 &gt; 2 交换位置 ( 2 3 4 0 8 ) → ( 2 3 4 0 8 )， 4 &gt; 3 位置不变 ( 2 3 4 0 8 ) → ( 2 3 0 4 8 )， 4 &gt; 0 交换位置</span></p></blockquote><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">第三次外循环（除开已经排序好的最后两个元素，对剩余的循环，直到剩余的序列为 1）</span></p><p><br></p><blockquote><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">( 2 3 0 4 8 ) → ( 2 3 0 4 8 )，3 &gt; 2 位置不变 (2 3 0 4 8 ) → (2 0 3 4 8 )，3 &gt; 0 交换位置</span></p></blockquote><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">第四次外循环（最后一次）</span></p><p><br></p><blockquote><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">( 2 0 3 4 8 ) → (0 2 3 4 8 )，2 &gt; 0 交换位置</span></p></blockquote><p><br></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">时间复杂度与空间复杂度</span></strong></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">由于我们要重复执行n次冒泡，每次冒泡要执行n次比较（实际是1到n的等差数列，也就是(a1 + an) * n / 2），也就是 O(n^2)。 空间复杂度是O(1)。</span></p><p><br></p><p style="text-align: justify;"><span style="color: rgb(171, 25, 66);"><strong><span style="font-size: 14px;"></span></strong></span></p><section label="Copyright © 2015 playhudong All Rights Reserved." style="border: none;margin: 1em auto;text-align: center;" donone="shifuMouseDownStyle(&#39;shifu_bus_003&#39;)"><section style="text-align: left;overflow: hidden;"><section class="" style="font-size: 1.125em;vertical-align: middle;line-height: 1.8em;text-align: center;padding-right: 0.5em;padding-bottom: 500px;padding-left: 0.5em;color: rgb(255, 255, 255);width: 16%;min-width: 1em;box-sizing: border-box;margin-bottom: -500px;display: inline-block;background-color: rgb(197, 63, 70);"><p class="">04</p></section><section style="vertical-align: top;padding-bottom: 500px;margin-bottom: -500px;width: 84%;box-sizing: border-box;background-color: #dedede;display: inline-block;"><section style="width: 6%;min-width: 1em;vertical-align: middle;display: inline-block;"><section class="" style="border-width: 0.5em 0px 0.5em 0.5em;border-style: solid;border-color: transparent transparent transparent rgb(197, 63, 70);vertical-align: middle;display: inline-block;"></section></section><section style="line-height: 1.5;font-size: 1.125em;padding-right: 0.8em;padding-left: 0.5em;vertical-align: middle;box-sizing: border-box;width: 94%;display: inline-block;"><p style="padding-top: 4px;">插入排序</p></section></section></section></section><p class=""><br></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">实现原理</span></strong></p><p><br></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p style="text-align: justify;"><span style="font-size: 14px;">认为第一个元素是排好序的，从第二个开始遍历。</span></p></li><li><p style="text-align: justify;"><span style="font-size: 14px;">拿出当前元素的值，从排好序的序列中从后往前找。</span></p></li><li><p style="text-align: justify;"><span style="font-size: 14px;">如果序列中的元素比当前元素大，就把它后移。直到找到一个小的。</span></p></li><li><p style="text-align: justify;"><span style="font-size: 14px;">把当前元素放在这个小的后面（后面的比当前大，它已经被后移了）。</span></p></li></ul><p><br></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">代码实现</span></strong></p><p><br></p><p><img data-s="300,640" data-type="png" data-src="http://mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjWZib4jQghCMfCbzw8wicCckAOiauwBrdq5N4qQV7TQ4JbH6ajKm5R63eCYsfZKicicMMSDIXUqjDeAcJw/0?wx_fmt=png" style="width: auto !important; height: auto !important; visibility: visible !important;" class="" data-ratio="0.47769516728624534" data-w="538" src="./常见的七种排序算法解析_files/640(6)" data-fail="0"></p><p style="text-align: justify;"><br></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">原理图解</span></strong></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">案例1</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_jpg/wvkocF2MXjWZib4jQghCMfCbzw8wicCckAeDTics5ibh2ibUesrFnzibcqGadPFj4U7bAegC0SR3t8eU1mvKrMEER6fQ/0?wx_fmt=jpeg" class="" data-ratio="1.3333333333333333" data-w="1080" data-type="jpeg" style="width: 370px !important; height: auto !important; visibility: visible !important;" _width="370px" src="./常见的七种排序算法解析_files/640(7)" data-fail="0"></span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">案例2</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_gif/wvkocF2MXjWZib4jQghCMfCbzw8wicCckAM0fOOcPHO81vzaQfTu9fOpFygqtP5jGXtcaMYmwSGIbw6icCichaJ8cQ/0?wx_fmt=gif" class=" __bg_gif" data-ratio="0.6" data-w="300" data-type="gif" src="./常见的七种排序算法解析_files/0" style="width: auto !important; height: auto !important; visibility: visible !important;" data-order="0" data-fail="0"></span></p><p><br></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">时间复杂度与空间复杂度</span></strong></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">因为要选择n次，而且插入时最坏要比较n次，所以时间复杂度同样是O(n^2)。空间复杂度是O(1)。</span></p><p><br></p><p style="text-align: justify;"><span style="color: rgb(171, 25, 66);"><strong><span style="font-size: 14px;"></span></strong></span></p><section label="Copyright © 2015 playhudong All Rights Reserved." style="border: none;margin: 1em auto;text-align: center;" donone="shifuMouseDownStyle(&#39;shifu_bus_003&#39;)"><section style="text-align: left;overflow: hidden;"><section class="" style="font-size: 1.125em;vertical-align: middle;line-height: 1.8em;text-align: center;padding-right: 0.5em;padding-bottom: 500px;padding-left: 0.5em;color: rgb(255, 255, 255);width: 16%;min-width: 1em;box-sizing: border-box;margin-bottom: -500px;display: inline-block;background-color: rgb(197, 63, 70);"><p class="">05</p></section><section style="vertical-align: top;padding-bottom: 500px;margin-bottom: -500px;width: 84%;box-sizing: border-box;background-color: #dedede;display: inline-block;"><section style="width: 6%;min-width: 1em;vertical-align: middle;display: inline-block;"><section class="" style="border-width: 0.5em 0px 0.5em 0.5em;border-style: solid;border-color: transparent transparent transparent rgb(197, 63, 70);vertical-align: middle;display: inline-block;"></section></section><section style="line-height: 1.5;font-size: 1.125em;padding-right: 0.8em;padding-left: 0.5em;vertical-align: middle;box-sizing: border-box;width: 94%;display: inline-block;"><p style="padding-top: 4px;">希尔排序</p></section></section></section></section><p class=""><br></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">实现原理</span></strong></p><p><br></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p style="text-align: justify;"><span style="font-size: 14px;">先取一个正整数 d1(d1 &lt; n)，把全部记录分成 d1 个组，所有距离为 d1 的倍数的记录看成一组，然后在各组内进行插入排序</span></p></li><li><p style="text-align: justify;"><span style="font-size: 14px;">然后取 d2(d2 &lt; d1)</span></p></li><li><p style="text-align: justify;"><span style="font-size: 14px;">重复上述分组和排序操作；直到取 di = 1(i &gt;= 1) 位置，即所有记录成为一个组，最后对这个组进行插入排序。一般选 d1 约为 n/2，d2 为 d1 /2， d3 为 d2/2 ，…， di = 1。</span></p></li></ul><p><br></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">代码实现</span></strong></p><p><br></p><p><img data-s="300,640" data-type="png" data-src="http://mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjWZib4jQghCMfCbzw8wicCckAE1ajhjqEevNVco30taGS0xxYZh0Lgu0w5ZxcheBibC4L9jY6TMO1vOg/0?wx_fmt=png" style="width: auto !important; height: auto !important; visibility: visible !important;" class="" data-ratio="0.5149911816578483" data-w="567" src="./常见的七种排序算法解析_files/640(8)" data-fail="0"></p><p style="text-align: justify;"><br></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">案例分析</span></strong></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">假设有数组 array = [80, 93, 60, 12, 42, 30, 68, 85, 10]，首先取 d1 = 4，将数组分为 4 组，如下图中相同颜色代表一组：</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjWZib4jQghCMfCbzw8wicCckAicZb8GXWpWu3OXrjtgl0rX08zqkYsrafjZPNk7aSemrvq5m3iaiadTQmg/0?wx_fmt=png" class="" data-ratio="0.2231404958677686" data-w="484" data-type="png" src="./常见的七种排序算法解析_files/640(9)" style="width: auto !important; height: auto !important; visibility: visible !important;" data-fail="0"></span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">然后分别对 4 个小组进行插入排序，排序后的结果为：</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjWZib4jQghCMfCbzw8wicCckA8ElicLTPwBQIia7gTBUeWs1RIarAswibhomqwSpiactlTA3BeNNZgH9zLA/0?wx_fmt=png" class="" data-ratio="0.2222222222222222" data-w="486" data-type="png" src="./常见的七种排序算法解析_files/640(10)" style="width: auto !important; height: auto !important; visibility: visible !important;" data-fail="0"></span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">然后，取 d2 = 2，将原数组分为 2 小组，如下图：</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjWZib4jQghCMfCbzw8wicCckARUn8Ly9Btv7FHfI0DRLAP3mWyTNUbciawqPDIfE3KIdSdLBbCfH9ibZg/0?wx_fmt=png" class="" data-ratio="0.22727272727272727" data-w="484" data-type="png" src="./常见的七种排序算法解析_files/640(11)" style="width: auto !important; height: auto !important; visibility: visible !important;" data-fail="0"></span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">然后分别对 2 个小组进行插入排序，排序后的结果为：</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjWZib4jQghCMfCbzw8wicCckAQMeDyT3elbQsvvFuHuc625pOn1YQVuwngauNhgeYCwhNUiantOYsXmQ/0?wx_fmt=png" class="" data-ratio="0.22520661157024793" data-w="484" data-type="png" src="./常见的七种排序算法解析_files/640(12)" style="width: auto !important; height: auto !important; visibility: visible !important;" data-fail="0"></span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">最后，取 d3 = 1，进行插入排序后得到最终结果：</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjWZib4jQghCMfCbzw8wicCckAI2R56EYJe9zKXiaocdv1IJegKsMQUbBePWTqjf9yQDPmu3k4LV0icmtA/0?wx_fmt=png" class="" data-ratio="0.36475409836065575" data-w="488" data-type="png" src="./常见的七种排序算法解析_files/640(13)" style="width: auto !important; height: auto !important; visibility: visible !important;" data-fail="0"></span></p><p><br></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">时间复杂度与空间复杂度</span></strong></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">希尔排序的时间复杂度受步长的影响，平均时间复杂度是O(n log2 n),空间复杂度是O(1)。</span></p><p><br></p><p style="text-align: justify;"><span style="color: rgb(171, 25, 66);"><strong><span style="font-size: 14px;"></span></strong></span></p><section label="Copyright © 2015 playhudong All Rights Reserved." style="border: none;margin: 1em auto;text-align: center;" donone="shifuMouseDownStyle(&#39;shifu_bus_003&#39;)"><section style="text-align: left;overflow: hidden;"><section class="" style="font-size: 1.125em;vertical-align: middle;line-height: 1.8em;text-align: center;padding-right: 0.5em;padding-bottom: 500px;padding-left: 0.5em;color: rgb(255, 255, 255);width: 16%;min-width: 1em;box-sizing: border-box;margin-bottom: -500px;display: inline-block;background-color: rgb(197, 63, 70);"><p class="">06</p></section><section style="vertical-align: top;padding-bottom: 500px;margin-bottom: -500px;width: 84%;box-sizing: border-box;background-color: #dedede;display: inline-block;"><section style="width: 6%;min-width: 1em;vertical-align: middle;display: inline-block;"><section class="" style="border-width: 0.5em 0px 0.5em 0.5em;border-style: solid;border-color: transparent transparent transparent rgb(197, 63, 70);vertical-align: middle;display: inline-block;"></section></section><section style="line-height: 1.5;font-size: 1.125em;padding-right: 0.8em;padding-left: 0.5em;vertical-align: middle;box-sizing: border-box;width: 94%;display: inline-block;"><p style="padding-top: 4px;">归并排序</p></section></section></section></section><p class=""><br></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">实现原理</span></strong></p><p><br></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p style="text-align: justify;"><span style="font-size: 14px;">把 n 个记录看成 n 个长度为 l 的有序子表</span></p></li><li><p style="text-align: justify;"><span style="font-size: 14px;">进行两两归并使记录关键字有序，得到 n/2 个长度为 2 的有序子表</span></p></li><li><p style="text-align: justify;"><span style="font-size: 14px;">重复第 2 步直到所有记录归并成一个长度为 n 的有序表为止。</span></p></li></ul><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">总而言之，归并排序就是使用递归，先分解数组为子数组，再合并数组。</span></p><p><br></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">代码实现</span></strong></p><p><br></p><blockquote><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; public static int[] mergeSort(int[] arr){</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; int[] temp =new int[arr.length];</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; internalMergeSort(arr, temp, 0, arr.length-1);</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; return temp;</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; }</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; private static void internalMergeSort(int[] a, int[] b, int left, int right){</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; //当left==right的时，已经不需要再划分了</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; if (left&lt;right){</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int middle = (left+right)/2;</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; internalMergeSort(a, b, left, middle); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//左子数组</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; internalMergeSort(a, b, middle+1, right); &nbsp; &nbsp; &nbsp; //右子数组</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mergeSortedArray(a, b, left, middle, right); &nbsp; &nbsp;//合并两个子数组</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; }</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; // 合并两个有序子序列 arr[left, ..., middle] 和 arr[middle+1, ..., right]。temp是辅助数组。</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; private static void mergeSortedArray(int arr[], int temp[], int left, int middle, int right){</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; int i=left;</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; int j=middle+1;</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; int k=0;</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; while ( i&lt;=middle &amp;&amp; j&lt;=right){</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (arr[i] &lt;=arr[j]){</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp[k++] = arr[i++];</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else{</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp[k++] = arr[j++];</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; while (i &lt;=middle){</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp[k++] = arr[i++];</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; while ( j&lt;=right){</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp[k++] = arr[j++];</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; //把数据复制回原数组</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; for (i=0; i&lt;k; ++i){</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arr[left+i] = temp[i];</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; }</span></p></blockquote><p style="text-align: justify;"><span style="font-size: 14px;"><br></span></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">案例分析</span></strong></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">案例1</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">以数组 array = [4 2 8 3 5 1 7 6] 为例，首先将数组分为长度为 2 的子数组，并使每个子数组有序：</span></p><p><br></p><blockquote><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">[4 2] [8 3] [5 1] [7 6] ↓</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">[2 4] [3 8] [1 5] [6 7]</span></p></blockquote><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">然后再两两合并：</span></p><p><br></p><blockquote><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">[2 4 3 8] [1 5 6 7] ↓</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">[2 3 4 8] [1 5 6 7]</span></p></blockquote><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">最后将两个子数组合并：</span></p><p><br></p><blockquote><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">[2 3 4 8 1 5 6 7] ↓</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">[1 2 3 4 5 6 7 8]</span></p></blockquote><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">案例2</span></p><p style="text-align: justify;"><span style="font-size: 14px;"><br></span></p><p style="text-align: justify;"><span style="font-size: 14px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_gif/wvkocF2MXjWZib4jQghCMfCbzw8wicCckAibTJeourhHaafClicDn8Tqpvkrpp9DMC8c9SNhxzACrpIR5NVCww8A0A/0?wx_fmt=gif" class=" __bg_gif" data-ratio="0.6" data-w="300" data-type="gif" src="./常见的七种排序算法解析_files/0(1)" style="width: auto !important; height: auto !important; visibility: visible !important;" data-order="1" data-fail="0"></span></p><p style="text-align: justify;"><span style="font-size: 14px;"><br></span></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">时间复杂度与空间复杂度</span></strong></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">在合并数组过程中，实际的操作是当前两个子数组的长度，即2m。又因为打散数组是二分的，最终循环执行数是logn。所以这个算法最终时间复杂度是O(nlogn)，空间复杂度是O(1)。</span></p><p><br></p><p style="text-align: justify;"><span style="color: rgb(171, 25, 66);"><strong><span style="font-size: 14px;"></span></strong></span></p><section label="Copyright © 2015 playhudong All Rights Reserved." style="border: none;margin: 1em auto;text-align: center;" donone="shifuMouseDownStyle(&#39;shifu_bus_003&#39;)"><section style="text-align: left;overflow: hidden;"><section class="" style="font-size: 1.125em;vertical-align: middle;line-height: 1.8em;text-align: center;padding-right: 0.5em;padding-bottom: 500px;padding-left: 0.5em;color: rgb(255, 255, 255);width: 16%;min-width: 1em;box-sizing: border-box;margin-bottom: -500px;display: inline-block;background-color: rgb(197, 63, 70);"><p class="">07</p></section><section style="vertical-align: top;padding-bottom: 500px;margin-bottom: -500px;width: 84%;box-sizing: border-box;background-color: #dedede;display: inline-block;"><section style="width: 6%;min-width: 1em;vertical-align: middle;display: inline-block;"><section class="" style="border-width: 0.5em 0px 0.5em 0.5em;border-style: solid;border-color: transparent transparent transparent rgb(197, 63, 70);vertical-align: middle;display: inline-block;"></section></section><section style="line-height: 1.5;font-size: 1.125em;padding-right: 0.8em;padding-left: 0.5em;vertical-align: middle;box-sizing: border-box;width: 94%;display: inline-block;"><p style="padding-top: 4px;">堆排序</p></section></section></section></section><p class=""><br></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">实现原理</span></strong></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。在堆中定义以下几种操作：</span></p><p><br></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p style="text-align: justify;"><span style="font-size: 14px;">最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</span></p></li><li><p style="text-align: justify;"><span style="font-size: 14px;">创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆</span></p></li><li><p style="text-align: justify;"><span style="font-size: 14px;">堆排序（Heap-Sort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</span></p></li></ul><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjWZib4jQghCMfCbzw8wicCckAdWN7nxqcd2IBNOQbxzrTneHDORTfHsyJ2tugdMuGTe0WrSQrc7Ovzw/0?wx_fmt=png" class="img_loading" data-ratio="0.34519572953736655" data-w="562" data-type="png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" style="width: 562px !important; height: 194px !important;"></span></p><p><br></p><ul class="list-paddingleft-2" style="list-style-type: disc;"><li><p style="text-align: justify;"><span style="font-size: 14px;">Parent(i) = floor((i-1)/2)，i 的父节点下标</span></p></li><li><p style="text-align: justify;"><span style="font-size: 14px;">Left(i) = 2i + 1，i 的左子节点下标</span></p></li><li><p style="text-align: justify;"><span style="font-size: 14px;">Right(i) = 2(i + 1)，i 的右子节点下标</span></p></li></ul><p><br></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">代码实现</span></strong></p><p><br></p><blockquote><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; /**</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp;* 堆排序</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp;*/</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; public static int[] heapSort(int[] arr) {</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; // 将待排序的序列构建成一个大顶堆</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; for (int i = arr.length / 2; i &gt;= 0; i--){</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heapAdjust(arr, i, arr.length);</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; // 逐步将每个最大值的根节点与末尾元素交换，并且再调整二叉树，使其成为大顶堆</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; for (int i = arr.length - 1; i &gt; 0; i--) {</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; swap(arr, 0, i); // 将堆顶记录和当前未经排序子序列的最后一个记录交换</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; heapAdjust(arr, 0, i); // 交换之后，需要重新检查堆是否符合大顶堆，不符合则要调整</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; return arr;</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; }</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; /**</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp;* 构建堆的过程</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp;* @param arr 需要排序的数组</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp;* @param i 需要构建堆的根节点的序号</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp;* @param n 数组的长度</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp;*/</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; private static void heapAdjust(int[] arr, int i, int n) {</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; int child;</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; int father;</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; for (father = arr[i]; leftChild(i) &lt; n; i = child) {</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child = leftChild(i);</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 如果左子树小于右子树，则需要比较右子树和父节点</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (child != n - 1 &amp;&amp; arr[child] &lt; arr[child + 1]) {</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; child++; // 序号增1，指向右子树</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 如果父节点小于孩子结点，则需要交换</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (father &lt; arr[child]) {</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arr[i] = arr[child];</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } else {</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break; // 大顶堆结构未被破坏，不需要调整</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; arr[i] = father;</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; }</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; // 获取到左孩子结点</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; private static int leftChild(int i) {</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; return 2 * i + 1;</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; }</span></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; // 交换元素位置</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; private static void swap(int[] arr, int index1, int index2) {</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; int tmp = arr[index1];</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; arr[index1] = arr[index2];</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; &nbsp; &nbsp; arr[index2] = tmp;</span></p><p style="text-align: justify;"><span style="font-size: 14px;color: rgb(136, 136, 136);">&nbsp; &nbsp; }</span></p></blockquote><p style="text-align: justify;"><span style="font-size: 14px;"><br></span></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">案例分析</span></strong></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;"><img data-src="http://mmbiz.qpic.cn/mmbiz_png/wvkocF2MXjWZib4jQghCMfCbzw8wicCckAD91iad98ZrehhzyGGdSR1icfnq0nIvIeQUSI431oCUtmz3pUbh7MRhqQ/0?wx_fmt=png" class="" data-ratio="1.533112582781457" data-w="604" data-type="png" src="./常见的七种排序算法解析_files/640(14)" style="width: auto !important; height: auto !important; visibility: visible !important;" data-fail="0"></span></p><p><br></p><p style="text-align: justify;"><strong><span style="font-size: 14px;">时间复杂度与空间复杂度</span></strong></p><p><br></p><p style="text-align: justify;"><span style="font-size: 14px;">堆执行一次调整需要O(logn)的时间，在排序过程中需要遍历所有元素执行堆调整，所以最终时间复杂度是O(nlogn)。空间复杂度是O(1)。</span>
 </html>